// Generated by CoffeeScript 1.9.3
var CONNECTION_ERRORS, Drafter, Dredd, Runner, applyConfiguration, async, blueprintTransactions, blueprintUtils, configureReporters, fs, glob, handleRuntimeProblems, logger, options, removeDuplicates, request, url,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  hasProp = {}.hasOwnProperty;

require('setimmediate');

glob = require('glob');

fs = require('fs');

Drafter = require('drafter');

async = require('async');

request = require('request');

url = require('url');

logger = require('./logger');

options = require('./options');

Runner = require('./transaction-runner');

applyConfiguration = require('./apply-configuration');

handleRuntimeProblems = require('./handle-runtime-problems');

blueprintTransactions = require('blueprint-transactions');

configureReporters = require('./configure-reporters');

blueprintUtils = require('./blueprint-utils');

CONNECTION_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE'];

removeDuplicates = function(arr) {
  return arr.reduce(function(alreadyProcessed, currentItem) {
    if (alreadyProcessed.indexOf(currentItem) === -1) {
      return alreadyProcessed.concat(currentItem);
    }
    return alreadyProcessed;
  }, []);
};

Dredd = (function() {
  function Dredd(config) {
    this.transactionsComplete = bind(this.transactionsComplete, this);
    this.init(config);
  }

  Dredd.prototype.init = function(config) {
    var base;
    this.tests = [];
    this.stats = {
      tests: 0,
      failures: 0,
      errors: 0,
      passes: 0,
      skipped: 0,
      start: 0,
      end: 0,
      duration: 0
    };
    this.configuration = applyConfiguration(config, this.stats);
    if ((base = this.configuration).options == null) {
      base.options = {};
    }
    this.runner = new Runner(this.configuration);
    return configureReporters(this.configuration, this.stats, this.tests, this.runner);
  };

  Dredd.prototype.run = function(callback) {
    var config, configDataIsEmpty, downloadFile, expandGlobs, key, loadFiles, parseBlueprints, passedConfigData, readLocalFile, ref, runtimes, startRunner, stats, val;
    config = this.configuration;
    stats = this.stats;
    configDataIsEmpty = true;
    if (config.files == null) {
      config.files = [];
    }
    if (config.data == null) {
      config.data = {};
    }
    runtimes = {};
    passedConfigData = {};
    ref = config.data || {};
    for (key in ref) {
      if (!hasProp.call(ref, key)) continue;
      val = ref[key];
      configDataIsEmpty = false;
      if (typeof val === 'string') {
        passedConfigData[key] = {
          filename: key,
          raw: val
        };
      } else if ((typeof val === 'object') && val.raw && val.filename) {
        passedConfigData[val.filename] = {
          filename: val.filename,
          raw: val.raw
        };
      }
    }
    if (!configDataIsEmpty) {
      config.data = passedConfigData;
    }
    config.options.path = removeDuplicates(config.options.path);
    expandGlobs = function(cb) {
      return async.each(config.options.path, function(globToExpand, globCallback) {
        if (/^http(s)?:\/\//.test(globToExpand)) {
          config.files = config.files.concat(globToExpand);
          return globCallback();
        }
        return glob(globToExpand, function(err, match) {
          if (err) {
            globCallback(err);
          }
          config.files = config.files.concat(match);
          return globCallback();
        });
      }, function(err) {
        if (err) {
          return callback(err, stats);
        }
        if (configDataIsEmpty && config.files.length === 0) {
          return callback({
            message: "Blueprint file or files not found on path: '" + config.options.path + "'"
          }, stats);
        }
        config.files = removeDuplicates(config.files);
        return cb();
      });
    };
    loadFiles = function(cb) {
      return async.eachLimit(config.files, 6, function(fileUrlOrPath, loadCallback) {
        var fileUrl, ref1;
        try {
          fileUrl = url.parse(fileUrlOrPath);
        } catch (_error) {
          fileUrl = null;
        }
        if (fileUrl && ((ref1 = fileUrl.protocol) === 'http:' || ref1 === 'https:') && fileUrl.host) {
          return downloadFile(fileUrlOrPath, loadCallback);
        } else {
          return readLocalFile(fileUrlOrPath, loadCallback);
        }
      }, function(err) {
        if (err) {
          return callback(err, stats);
        }
        return cb();
      });
    };
    downloadFile = function(fileUrl, downloadCallback) {
      return request.get({
        url: fileUrl,
        timeout: 5000,
        json: false
      }, function(downloadError, res, body) {
        if (downloadError) {
          return downloadCallback({
            message: "Error when loading file from URL '" + fileUrl + "'. Is the provided URL correct?"
          });
        } else if (!body || res.statusCode < 200 || res.statusCode >= 300) {
          return downloadCallback({
            message: "Unable to load file from URL '" + fileUrl + "'. Server did not send any blueprint back and responded with status code " + res.statusCode + "."
          });
        } else {
          config.data[fileUrl] = {
            raw: body,
            filename: fileUrl
          };
          return downloadCallback();
        }
      });
    };
    readLocalFile = function(filePath, readCallback) {
      return fs.readFile(filePath, 'utf8', function(readingError, data) {
        if (readingError) {
          return readCallback(readingError);
        }
        config.data[filePath] = {
          raw: data,
          filename: filePath
        };
        return readCallback();
      });
    };
    parseBlueprints = function(cb) {
      return async.each(Object.keys(config.data), function(file, parseCallback) {
        var drafter;
        drafter = new Drafter;
        return drafter.make(config.data[file]['raw'], function(drafterError, result) {
          if (drafterError) {
            return parseCallback(drafterError);
          }
          config.data[file]['parsed'] = result;
          return parseCallback();
        });
      }, function(err) {
        var data, file, i, len, message, pos, ranges, ref1, ref2, ref3, result, runtime, runtimeError, warning;
        if (err) {
          return callback(err, config.reporter);
        }
        ref1 = config.data;
        for (file in ref1) {
          data = ref1[file];
          result = data['parsed'];
          if (result['warnings'].length > 0) {
            ref2 = result['warnings'];
            for (i = 0, len = ref2.length; i < len; i++) {
              warning = ref2[i];
              message = ("Parser warning in file '" + file + "':") + ' (' + warning.code + ') ' + warning.message;
              ranges = blueprintUtils.warningLocationToRanges(warning['location'], data['raw']);
              if (ranges != null ? ranges.length : void 0) {
                pos = blueprintUtils.rangesToLinesText(ranges);
                message = message + ' on ' + pos;
              }
              logger.warn(message);
            }
          }
        }
        runtimes['warnings'] = [];
        runtimes['errors'] = [];
        runtimes['transactions'] = [];
        ref3 = config.data;
        for (file in ref3) {
          data = ref3[file];
          runtime = blueprintTransactions.compile(data['parsed']['ast'], file);
          runtimes['warnings'] = runtimes['warnings'].concat(runtime['warnings']);
          runtimes['errors'] = runtimes['errors'].concat(runtime['errors']);
          runtimes['transactions'] = runtimes['transactions'].concat(runtime['transactions']);
        }
        runtimeError = handleRuntimeProblems(runtimes);
        if (runtimeError) {
          return callback(runtimeError, stats);
        }
        return cb();
      });
    };
    startRunner = (function(_this) {
      return function() {
        var reporterCount;
        reporterCount = config.emitter.listeners('start').length;
        return config.emitter.emit('start', config.data, function() {
          reporterCount--;
          if (reporterCount === 0) {
            _this.runner.config(config);
            return _this.runner.run(runtimes['transactions'], function() {
              return _this.transactionsComplete(callback);
            });
          }
        });
      };
    })(this);
    return expandGlobs(function() {
      return loadFiles(function() {
        return parseBlueprints(function() {
          return startRunner();
        });
      });
    });
  };

  Dredd.prototype.transactionsComplete = function(callback) {
    var reporterCount, stats;
    stats = this.stats;
    reporterCount = this.configuration.emitter.listeners('end').length;
    return this.configuration.emitter.emit('end', function() {
      reporterCount--;
      if (reporterCount === 0) {
        return callback(null, stats);
      }
    });
  };

  return Dredd;

})();

module.exports = Dredd;

module.exports.options = options;
